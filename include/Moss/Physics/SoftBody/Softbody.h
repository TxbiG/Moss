class MassProperties {
public:
	// Using eigendecomposition, decompose the inertia tensor into a diagonal matrix D and a right-handed rotation matrix R so that the inertia tensor is \f$R \: D \: R^{-1}\f$.
	// @see https://en.wikipedia.org/wiki/Moment_of_inertia section 'Principal axes'
	// @param outRotation The rotation matrix R
	// @param outDiagonal The diagonal of the diagonal matrix D
	// @return True if successful, false if failed
	bool DecomposePrincipalMomentsOfInertia(Mat44 &outRotation, Vec3 &outDiagonal) const;

	// Set the mass and inertia of a box with edge size inBoxSize and density inDensity
	void					SetMassAndInertiaOfSolidBox(Vec3Arg inBoxSize, float inDensity);
	// Set the mass and scale the inertia tensor to match the mass
	void					ScaleToMass(float inMass);
	// Calculates the size of the solid box that has an inertia tensor diagonal inInertiaDiagonal
	static Vec3				sGetEquivalentSolidBoxSize(float inMass, Vec3Arg inInertiaDiagonal);
	// Rotate the inertia by 3x3 matrix inRotation
	void					Rotate(Mat44Arg inRotation);
	// Translate the inertia by a vector inTranslation
	void					Translate(Vec3Arg inTranslation);
	// Scale the mass and inertia by inScale, note that elements can be < 0 to flip the shape
	void					Scale(Vec3Arg inScale);
	// Saves the state of this object in binary form to inStream.
	void					SaveBinaryState(StreamOut &inStream) const;
	// Restore the state of this object from inStream.
	void					RestoreBinaryState(StreamIn &inStream);
	// Mass of the shape (kg)
	float					mMass = 0.0f;
	// Inertia tensor of the shape (kg m^2)
	Mat44					mInertia = Mat44::sZero();
};

// A listener class that receives collision contact events for soft bodies against rigid bodies.
// It can be registered with the PhysicsSystem.
class SoftBodyContactListener
{
public:
	// Ensure virtual destructor
	virtual							~SoftBodyContactListener() = default;

	// Called whenever the soft body's aabox overlaps with another body's aabox (so receiving this callback doesn't tell if any of the vertices will collide).
	// This callback can be used to change the behavior of the collision response for all vertices in the soft body or to completely reject the contact.
	// Note that this callback is called when all bodies are locked, so don't use any locking functions!
	// @param inSoftBody The soft body that collided. It is safe to access this as the soft body is only updated on the current thread.
	// @param inOtherBody The other body that collided. Note that accessing the position/orientation/velocity of inOtherBody may result in a race condition as other threads may be modifying the body at the same time.
	// @param ioSettings The settings for all contact points that are generated by this collision.
	// @return Whether the contact should be processed or not.
	virtual SoftBodyValidateResult	OnSoftBodyContactValidate([[maybe_unused]] const Body &inSoftBody, [[maybe_unused]] const Body &inOtherBody, [[maybe_unused]] SoftBodyContactSettings &ioSettings) { return SoftBodyValidateResult::AcceptContact; }

	// Called after all contact points for a soft body have been handled. You only receive one callback per body pair per simulation step and can use inManifold to iterate through all contacts.
	// Note that this callback is called when all bodies are locked, so don't use any locking functions!
	// You will receive a single callback for a soft body per simulation step for performance reasons, this callback will apply to all vertices in the soft body.
	// @param inSoftBody The soft body that collided. It is safe to access this as the soft body is only updated on the current thread.
	// @param inManifold The manifold that describes the contact surface between the two bodies. Other bodies may be modified by other threads during this callback.
	virtual void					OnSoftBodyContactAdded([[maybe_unused]] const Body &inSoftBody, const SoftBodyManifold &inManifold) { /* Do nothing */ }
};

// Temporary data used by the update of a soft body
class SoftBodyUpdateContext : public NonCopyable
{
public:
	static constexpr uint				cVertexCollisionBatch = 64;					// Number of vertices to process in a batch in DetermineCollisionPlanes
	static constexpr uint				cVertexConstraintBatch = 256;				// Number of vertices to group for processing batches of constraints in ApplyEdgeConstraints

	// Input
	Body*								mBody;										// Body that is being updated
	SoftBodyMotionProperties*			mMotionProperties;							// Motion properties of that body
	SoftBodyContactListener*			mContactListener;							// Contact listener to fire callbacks to
	const SimShapeFilter*				mSimShapeFilter;							// Shape filter to use for collision detection
	RMat44								mCenterOfMassTransform;						// Transform of the body relative to the soft body
	Vec3								mGravity;									// Gravity vector in local space of the soft body
	Vec3								mDisplacementDueToGravity;					// Displacement of the center of mass due to gravity in the current time step
	float								mDeltaTime;									// Delta time for the current time step
	float								mSubStepDeltaTime;							// Delta time for each sub step

	// Describes progress in the current update
	enum class EState
	{
		DetermineCollisionPlanes,													// Determine collision planes for vertices in parallel
		DetermineSensorCollisions,													// Determine collisions with sensors in parallel
		ApplyConstraints,															// Apply constraints in parallel
		Done																		// Update is finished
	};

	// State of the update
	atomic<EState>						mState { EState::DetermineCollisionPlanes };// Current state of the update
	atomic<uint>						mNextCollisionVertex { 0 };					// Next vertex to process for DetermineCollisionPlanes
	atomic<uint>						mNumCollisionVerticesProcessed { 0 };		// Number of vertices processed by DetermineCollisionPlanes, used to determine if we can go to the next step
	atomic<uint>						mNextSensorIndex { 0 };						// Next sensor to process for DetermineCollisionPlanes
	atomic<uint>						mNumSensorsProcessed { 0 };					// Number of sensors processed by DetermineSensorCollisions, used to determine if we can go to the next step
	atomic<uint>						mNextIteration { 0 };						// Next simulation iteration to process
	atomic<uint>						mNextConstraintGroup { 0 };					// Next constraint group to process
	atomic<uint>						mNumConstraintGroupsProcessed { 0 };		// Number of groups processed, used to determine if we can go to the next iteration

	// Output
	Vec3								mDeltaPosition;								// Delta position of the body in the current time step, should be applied after the update
	ECanSleep							mCanSleep;									// Can the body sleep? Should be applied after the update
};


// Run time information for a single particle of a soft body
// Note that at run-time you should only modify the inverse mass and/or velocity of a vertex to control the soft body.
// Modifying the position can lead to missed collisions.
// The other members are used internally by the soft body solver.
class SoftBodyVertex
{
public:
	// Reset collision information to prepare for a new collision check
	inline void		ResetCollision()
	{
		mLargestPenetration = -FLT_MAX;
		mCollidingShapeIndex = -1;
		mHasContact = false;
	}

	Vec3			mPreviousPosition;					// Internal use only. Position at the previous time step
	Vec3			mPosition;							// Position, relative to the center of mass of the soft body
	Vec3			mVelocity;							// Velocity, relative to the center of mass of the soft body
	Plane			mCollisionPlane;					// Internal use only. Nearest collision plane, relative to the center of mass of the soft body
	int				mCollidingShapeIndex;				// Internal use only. Index in the colliding shapes list of the body we may collide with
	bool			mHasContact;						// True if the vertex has collided with anything in the last update
	float			mLargestPenetration;				// Internal use only. Used while finding the collision plane, stores the largest penetration found so far
	float			mInvMass;							// Inverse mass (1 / mass)
};

// An interface to query which vertices of a soft body are colliding with other bodies
class SoftBodyManifold
{
public:
	// Get the vertices of the soft body for iterating
	const TArray<SoftBodyVertex> &	GetVertices() const							{ return mVertices; }

	// Check if a vertex has collided with something in this update
	MOSS_INLINE bool					HasContact(const SoftBodyVertex &inVertex) const
	{
		return inVertex.mHasContact;
	}

	// Get the local space contact point (multiply by GetCenterOfMassTransform() of the soft body to get world space)
	MOSS_INLINE Vec3					GetLocalContactPoint(const SoftBodyVertex &inVertex) const
	{
		return inVertex.mPosition - inVertex.mCollisionPlane.SignedDistance(inVertex.mPosition) * inVertex.mCollisionPlane.GetNormal();
	}

	// Get the contact normal for the vertex (assumes there is a contact).
	MOSS_INLINE Vec3					GetContactNormal(const SoftBodyVertex &inVertex) const
	{
		return -inVertex.mCollisionPlane.GetNormal();
	}

	// Get the body with which the vertex has collided in this update
	MOSS_INLINE BodyID				GetContactBodyID(const SoftBodyVertex &inVertex) const
	{
		return inVertex.mHasContact? mCollidingShapes[inVertex.mCollidingShapeIndex].mBodyID : BodyID();
	}

	// Get the number of sensors that are in contact with the soft body
	MOSS_INLINE uint					GetNumSensorContacts() const
	{
		return (uint)mCollidingSensors.size();
	}

	// Get the i-th sensor that is in contact with the soft body
	MOSS_INLINE BodyID				GetSensorContactBodyID(uint inIndex) const
	{
		return mCollidingSensors[inIndex].mBodyID;
	}

private:
	// Allow SoftBodyMotionProperties to construct us
	friend class SoftBodyMotionProperties;

	// Constructor
	explicit						SoftBodyManifold(const SoftBodyMotionProperties *inMotionProperties) :
										mVertices(inMotionProperties->mVertices),
										mCollidingShapes(inMotionProperties->mCollidingShapes),
										mCollidingSensors(inMotionProperties->mCollidingSensors)
	{
	}

	using CollidingShape = SoftBodyMotionProperties::CollidingShape;
	using CollidingSensor = SoftBodyMotionProperties::CollidingSensor;

	const TArray<SoftBodyVertex>&	mVertices;
	const TArray<CollidingShape>&	mCollidingShapes;
	const TArray<CollidingSensor>&	mCollidingSensors;
};

class MOSS_EXPORT SoftBodyMotionProperties : public MotionProperties
{
public:
	using Vertex = SoftBodyVertex;
	using Edge = SoftBodySharedSettings::Edge;
	using Face = SoftBodySharedSettings::Face;
	using DihedralBend = SoftBodySharedSettings::DihedralBend;
	using Volume = SoftBodySharedSettings::Volume;
	using InvBind = SoftBodySharedSettings::InvBind;
	using SkinWeight = SoftBodySharedSettings::SkinWeight;
	using Skinned = SoftBodySharedSettings::Skinned;
	using LRA = SoftBodySharedSettings::LRA;

	// Initialize the soft body motion properties
	void								Initialize(const SoftBodyCreationSettings &inSettings);

	// Get the shared settings of the soft body
	const SoftBodySharedSettings *		GetSettings() const							{ return mSettings; }

	// Get the vertices of the soft body
	const TArray<Vertex> &				GetVertices() const							{ return mVertices; }
	TArray<Vertex> &						GetVertices()								{ return mVertices; }

	// Access an individual vertex
	const Vertex &						GetVertex(uint inIndex) const				{ return mVertices[inIndex]; }
	Vertex &							GetVertex(uint inIndex)						{ return mVertices[inIndex]; }

	// Get the materials of the soft body
	const PhysicsMaterialList &			GetMaterials() const						{ return mSettings->mMaterials; }

	// Get the faces of the soft body
	const TArray<Face> &					GetFaces() const							{ return mSettings->mFaces; }

	// Access to an individual face
	const Face &						GetFace(uint inIndex) const					{ return mSettings->mFaces[inIndex]; }

	// Get the number of solver iterations
	uint32								GetNumIterations() const					{ return mNumIterations; }
	void								SetNumIterations(uint32 inNumIterations)	{ mNumIterations = inNumIterations; }

	// Get the pressure of the soft body
	float								GetPressure() const							{ return mPressure; }
	void								SetPressure(float inPressure)				{ mPressure = inPressure; }

	// Update the position of the body while simulating (set to false for something that is attached to the static world)
	bool								GetUpdatePosition() const					{ return mUpdatePosition; }
	void								SetUpdatePosition(bool inUpdatePosition)	{ mUpdatePosition = inUpdatePosition; }

	// Global setting to turn on/off skin constraints
	bool								GetEnableSkinConstraints() const			{ return mEnableSkinConstraints; }
	void								SetEnableSkinConstraints(bool inEnableSkinConstraints) { mEnableSkinConstraints = inEnableSkinConstraints; }

	// Multiplier applied to Skinned::mMaxDistance to allow tightening or loosening of the skin constraints. 0 to hard skin all vertices.
	float								GetSkinnedMaxDistanceMultiplier() const		{ return mSkinnedMaxDistanceMultiplier; }
	void								SetSkinnedMaxDistanceMultiplier(float inSkinnedMaxDistanceMultiplier) { mSkinnedMaxDistanceMultiplier = inSkinnedMaxDistanceMultiplier; }

	// Get local bounding box
	const AABox &						GetLocalBounds() const						{ return mLocalBounds; }

	// Get the volume of the soft body. Note can become negative if the shape is inside out!
	float								GetVolume() const							{ return GetVolumeTimesSix() / 6.0f; }

	// Calculate the total mass and inertia of this body based on the current state of the vertices
	void								CalculateMassAndInertia();

#ifndef MOSS_DEBUG_RENDERER
	// Draw the state of a soft body
	void								DrawVertices(DebugRenderer *inRenderer, RMat44Arg inCenterOfMassTransform) const;
	void								DrawVertexVelocities(DebugRenderer *inRenderer, RMat44Arg inCenterOfMassTransform) const;
	void								DrawEdgeConstraints(DebugRenderer *inRenderer, RMat44Arg inCenterOfMassTransform, ESoftBodyConstraintColor inConstraintColor) const;
	void								DrawBendConstraints(DebugRenderer *inRenderer, RMat44Arg inCenterOfMassTransform, ESoftBodyConstraintColor inConstraintColor) const;
	void								DrawVolumeConstraints(DebugRenderer *inRenderer, RMat44Arg inCenterOfMassTransform, ESoftBodyConstraintColor inConstraintColor) const;
	void								DrawSkinConstraints(DebugRenderer *inRenderer, RMat44Arg inCenterOfMassTransform, ESoftBodyConstraintColor inConstraintColor) const;
	void								DrawLRAConstraints(DebugRenderer *inRenderer, RMat44Arg inCenterOfMassTransform, ESoftBodyConstraintColor inConstraintColor) const;
	void								DrawPredictedBounds(DebugRenderer *inRenderer, RMat44Arg inCenterOfMassTransform) const;
#endif // MOSS_DEBUG_RENDERER

	// Saving state for replay
	void								SaveState(StateRecorder &inStream) const;

	// Restoring state for replay
	void								RestoreState(StateRecorder &inStream);

	// Skin vertices to supplied joints, information is used by the skinned constraints.
	// @param inCenterOfMassTransform Value of Body::GetCenterOfMassTransform().
	// @param inJointMatrices The joint matrices must be expressed relative to inCenterOfMassTransform.
	// @param inNumJoints Indicates how large the inJointMatrices array is (used only for validating out of bounds).
	// @param inHardSkinAll Can be used to position all vertices on the skinned vertices and can be used to hard reset the soft body.
	// @param ioTempAllocator Allocator.
	void								SkinVertices(RMat44Arg inCenterOfMassTransform, const Mat44 *inJointMatrices, uint inNumJoints, bool inHardSkinAll, TempAllocator &ioTempAllocator);

	// This function allows you to update the soft body immediately without going through the PhysicsSystem.
	// This is useful if the soft body is teleported and needs to 'settle' or it can be used if a the soft body
	// is not added to the PhysicsSystem and needs to be updated manually. One reason for not adding it to the
	// PhysicsSystem is that you might want to update a soft body immediately after updating an animated object
	// that has the soft body attached to it. If the soft body is added to the PhysicsSystem it will be updated
	// by it, so calling this function will effectively update it twice. Note that when you use this function,
	// only the current thread will be used, whereas if you update through the PhysicsSystem, multiple threads may
	// be used.
	// Note that this will bypass any sleep checks. Since the dynamic objects that the soft body touches
	// will not move during this call, there can be simulation artifacts if you call this function multiple times
	// without running the physics simulation step.
	void								CustomUpdate(float inDeltaTime, Body &ioSoftBody, PhysicsSystem &inSystem);

	////////////////////////////////////////
	// FUNCTIONS BELOW THIS LINE ARE FOR INTERNAL USE ONLY
	////////////////////////////////////////

	// Initialize the update context. Not part of the public API.
	void								InitializeUpdateContext(float inDeltaTime, Body &inSoftBody, const PhysicsSystem &inSystem, SoftBodyUpdateContext &ioContext);

	// Do a broad phase check and collect all bodies that can possibly collide with this soft body. Not part of the public API.
	void								DetermineCollidingShapes(const SoftBodyUpdateContext &inContext, const PhysicsSystem &inSystem, const BodyLockInterface &inBodyLockInterface);

	// Return code for ParallelUpdate
	enum class EStatus
	{
		NoWork	= 1 << 0,				// No work was done because other threads were still working on a batch that cannot run concurrently
		DidWork	= 1 << 1,				// Work was done to progress the update
		Done	= 1 << 2,				// All work is done
	};

	// Update the soft body, will process a batch of work. Not part of the public API.
	EStatus								ParallelUpdate(SoftBodyUpdateContext &ioContext, const PhysicsSettings &inPhysicsSettings);

	// Update the velocities of all rigid bodies that we collided with. Not part of the public API.
	void								UpdateRigidBodyVelocities(const SoftBodyUpdateContext &inContext, BodyInterface &inBodyInterface);

private:
	// SoftBodyManifold needs to have access to CollidingShape
	friend class SoftBodyManifold;

	// Information about a leaf shape that we're colliding with
	struct LeafShape
	{
										LeafShape() = default;
										LeafShape(Mat44Arg inTransform, Vec3Arg inScale, const Shape *inShape) : mTransform(inTransform), mScale(inScale), mShape(inShape) { }

		Mat44							mTransform;									// Transform of the shape relative to the soft body
		Vec3							mScale;										// Scale of the shape
		RefConst<Shape>					mShape;										// Shape
	};

	// Collect information about the colliding bodies
	struct CollidingShape
	{
		// Get the velocity of a point on this body
		Vec3							GetPointVelocity(Vec3Arg inPointRelativeToCOM) const
		{
			return mLinearVelocity + mAngularVelocity.Cross(inPointRelativeToCOM);
		}

		Mat44							mCenterOfMassTransform;						// Transform of the body relative to the soft body
		TArray<LeafShape>				mShapes;									// Leaf shapes of the body we hit
		BodyID							mBodyID;									// Body ID of the body we hit
		EMotionType						mMotionType;								// Motion type of the body we hit
		float							mInvMass;									// Inverse mass of the body we hit
		float							mFriction;									// Combined friction of the two bodies
		float							mRestitution;								// Combined restitution of the two bodies
		float							mSoftBodyInvMassScale;						// Scale factor for the inverse mass of the soft body vertices
		bool							mUpdateVelocities;							// If the linear/angular velocity changed and the body needs to be updated
		Mat44							mInvInertia;								// Inverse inertia in local space to the soft body
		Vec3							mLinearVelocity;							// Linear velocity of the body in local space to the soft body
		Vec3							mAngularVelocity;							// Angular velocity of the body in local space to the soft body
		Vec3							mOriginalLinearVelocity;					// Linear velocity of the body in local space to the soft body at start
		Vec3							mOriginalAngularVelocity;					// Angular velocity of the body in local space to the soft body at start
	};

	// Collect information about the colliding sensors
	struct CollidingSensor
	{
		Mat44							mCenterOfMassTransform;						// Transform of the body relative to the soft body
		TArray<LeafShape>				mShapes;									// Leaf shapes of the body we hit
		BodyID							mBodyID;									// Body ID of the body we hit
		bool							mHasContact;								// If the sensor collided with the soft body
	};

	// Information about the state of all skinned vertices
	struct SkinState
	{
		Vec3							mPreviousPosition = Vec3::sZero();			// Previous position of the skinned vertex, used to interpolate between the previous and current position
		Vec3							mPosition = Vec3::sNaN();					// Current position of the skinned vertex
		Vec3							mNormal = Vec3::sNaN();						// Normal of the skinned vertex
	};

	// Do a narrow phase check and determine the closest feature that we can collide with
	void								DetermineCollisionPlanes(uint inVertexStart, uint inNumVertices);

	// Do a narrow phase check between a single sensor and the soft body
	void								DetermineSensorCollisions(CollidingSensor &ioSensor);

	// Apply pressure force and update the vertex velocities
	void								ApplyPressure(const SoftBodyUpdateContext &inContext);

	// Integrate the positions of all vertices by 1 sub step
	void								IntegratePositions(const SoftBodyUpdateContext &inContext);

	// Enforce all bend constraints
	void								ApplyDihedralBendConstraints(const SoftBodyUpdateContext &inContext, uint inStartIndex, uint inEndIndex);

	// Enforce all volume constraints
	void								ApplyVolumeConstraints(const SoftBodyUpdateContext &inContext, uint inStartIndex, uint inEndIndex);

	// Enforce all skin constraints
	void								ApplySkinConstraints(const SoftBodyUpdateContext &inContext, uint inStartIndex, uint inEndIndex);

	// Enforce all edge constraints
	void								ApplyEdgeConstraints(const SoftBodyUpdateContext &inContext, uint inStartIndex, uint inEndIndex);

	// Enforce all LRA constraints
	void								ApplyLRAConstraints(uint inStartIndex, uint inEndIndex);

	// Enforce all collision constraints & update all velocities according the XPBD algorithm
	void								ApplyCollisionConstraintsAndUpdateVelocities(const SoftBodyUpdateContext &inContext);

	// Update the state of the soft body (position, velocity, bounds)
	void								UpdateSoftBodyState(SoftBodyUpdateContext &ioContext, const PhysicsSettings &inPhysicsSettings);

	// Start the first solver iteration
	void								StartFirstIteration(SoftBodyUpdateContext &ioContext);

	// Executes tasks that need to run on the start of an iteration (i.e. the stuff that can't run in parallel)
	void								StartNextIteration(const SoftBodyUpdateContext &ioContext);

	// Helper function for ParallelUpdate that works on batches of collision planes
	EStatus								ParallelDetermineCollisionPlanes(SoftBodyUpdateContext &ioContext);

	// Helper function for ParallelUpdate that works on sensor collisions
	EStatus								ParallelDetermineSensorCollisions(SoftBodyUpdateContext &ioContext);

	// Helper function for ParallelUpdate that works on batches of constraints
	EStatus								ParallelApplyConstraints(SoftBodyUpdateContext &ioContext, const PhysicsSettings &inPhysicsSettings);

	// Helper function to update a single group of constraints
	void								ProcessGroup(const SoftBodyUpdateContext &ioContext, uint inGroupIndex);

	// Returns 6 times the volume of the soft body
	float								GetVolumeTimesSix() const;

#ifndef MOSS_DEBUG_RENDERER
	// Helper function to draw constraints
	template <typename GetEndIndex, typename DrawConstraint>
		inline void						DrawConstraints(ESoftBodyConstraintColor inConstraintColor, const GetEndIndex &inGetEndIndex, const DrawConstraint &inDrawConstraint, ColorArg inBaseColor) const;

	RMat44								mSkinStateTransform = RMat44::sIdentity();	// The matrix that transforms mSkinState to world space
#endif // MOSS_DEBUG_RENDERER

	RefConst<SoftBodySharedSettings>	mSettings;									// Configuration of the particles and constraints
	TArray<Vertex>						mVertices;									// Current state of all vertices in the simulation
	TArray<CollidingShape>				mCollidingShapes;							// List of colliding shapes retrieved during the last update
	TArray<CollidingSensor>				mCollidingSensors;							// List of colliding sensors retrieved during the last update
	TArray<SkinState>					mSkinState;									// List of skinned positions (1-on-1 with mVertices but only those that are used by the skinning constraints are filled in)
	AABox								mLocalBounds;								// Bounding box of all vertices
	AABox								mLocalPredictedBounds;						// Predicted bounding box for all vertices using extrapolation of velocity by last step delta time
	uint32								mNumIterations;								// Number of solver iterations
	uint								mNumSensors;								// Workaround for TSAN false positive: store mCollidingSensors.size() in a separate variable.
	float								mPressure;									// n * R * T, amount of substance * ideal gas constant * absolute temperature, see https://en.wikipedia.org/wiki/Pressure
	float								mSkinnedMaxDistanceMultiplier = 1.0f;		// Multiplier applied to Skinned::mMaxDistance to allow tightening or loosening of the skin constraints
	bool								mUpdatePosition;							// Update the position of the body while simulating (set to false for something that is attached to the static world)
	atomic<bool>						mNeedContactCallback = false;				// True if the soft body has collided with anything in the last update
	bool								mEnableSkinConstraints = true;				// If skin constraints are enabled
	bool								mSkinStatePreviousPositionValid = false;	// True if the skinning was updated in the last update so that the previous position of the skin state is valid
};

class MOSS_EXPORT SoftBodySharedSettings : public RefTarget<SoftBodySharedSettings>
{
	MOSS_DECLARE_SERIALIZABLE_NON_VIRTUAL(MOSS_EXPORT, SoftBodySharedSettings)

public:
	// Which type of bend constraint should be created
	enum class EBendType
	{
		None,														// No bend constraints will be created
		Distance,													// A simple distance constraint
		Dihedral,													// A dihedral bend constraint (most expensive, but also supports triangles that are initially not in the same plane)
	};

	// The type of long range attachment constraint to create
	enum class ELRAType
	{
		None,														// Don't create a LRA constraint
		EuclideanDistance,											// Create a LRA constraint based on Euclidean distance between the closest kinematic vertex and this vertex
		GeodesicDistance,											// Create a LRA constraint based on the geodesic distance between the closest kinematic vertex and this vertex (follows the edge constraints)
	};

	// Per vertex attributes used during the CreateConstraints function.
	// For an edge or shear constraint, the compliance is averaged between the two attached vertices.
	// For a bend constraint, the compliance is averaged between the two vertices on the shared edge.
	struct MOSS_EXPORT VertexAttributes
	{
		// Constructor
						VertexAttributes() = default;
						VertexAttributes(float inCompliance, float inShearCompliance, float inBendCompliance, ELRAType inLRAType = ELRAType::None, float inLRAMaxDistanceMultiplier = 1.0f) : mCompliance(inCompliance), mShearCompliance(inShearCompliance), mBendCompliance(inBendCompliance), mLRAType(inLRAType), mLRAMaxDistanceMultiplier(inLRAMaxDistanceMultiplier) { }

		float			mCompliance = 0.0f;							// The compliance of the normal edges. Set to FLT_MAX to disable regular edges for any edge involving this vertex.
		float			mShearCompliance = 0.0f;					// The compliance of the shear edges. Set to FLT_MAX to disable shear edges for any edge involving this vertex.
		float			mBendCompliance = FLT_MAX;					// The compliance of the bend edges. Set to FLT_MAX to disable bend edges for any bend constraint involving this vertex.
		ELRAType		mLRAType = ELRAType::None;					// The type of long range attachment constraint to create.
		float			mLRAMaxDistanceMultiplier = 1.0f;			// Multiplier for the max distance of the LRA constraint, e.g. 1.01 means the max distance is 1% longer than the calculated distance in the rest pose.
	};

	// Automatically create constraints based on the faces of the soft body
	// @param inVertexAttributes A list of attributes for each vertex (1-on-1 with mVertices, note that if the list is smaller than mVertices the last element will be repeated). This defines the properties of the constraints that are created.
	// @param inVertexAttributesLength The length of inVertexAttributes
	// @param inBendType The type of bend constraint to create
	// @param inAngleTolerance Shear edges are created when two connected triangles form a quad (are roughly in the same plane and form a square with roughly 90 degree angles). This defines the tolerance (in radians).
	void				CreateConstraints(const VertexAttributes *inVertexAttributes, uint inVertexAttributesLength, EBendType inBendType = EBendType::Distance, float inAngleTolerance = DegreesToRadians(8.0f));

	// Calculate the initial lengths of all springs of the edges of this soft body (if you use CreateConstraint, this is already done)
	void				CalculateEdgeLengths();

	// Calculate the max lengths for the long range attachment constraints based on Euclidean distance (if you use CreateConstraints, this is already done)
	// @param inMaxDistanceMultiplier Multiplier for the max distance of the LRA constraint, e.g. 1.01 means the max distance is 1% longer than the calculated distance in the rest pose.
	void				CalculateLRALengths(float inMaxDistanceMultiplier = 1.0f);

	// Calculate the constants for the bend constraints (if you use CreateConstraints, this is already done)
	void				CalculateBendConstraintConstants();

	// Calculates the initial volume of all tetrahedra of this soft body
	void				CalculateVolumeConstraintVolumes();

	// Calculate information needed to be able to calculate the skinned constraint normals at run-time
	void				CalculateSkinnedConstraintNormals();

	// Information about the optimization of the soft body, the indices of certain elements may have changed.
	class OptimizationResults
	{
	public:
		TArray<uint>		mEdgeRemap;									// Maps old edge index to new edge index
		TArray<uint>		mLRARemap;									// Maps old LRA index to new LRA index
		TArray<uint>		mDihedralBendRemap;							// Maps old dihedral bend index to new dihedral bend index
		TArray<uint>		mVolumeRemap;								// Maps old volume constraint index to new volume constraint index
		TArray<uint>		mSkinnedRemap;								// Maps old skinned constraint index to new skinned constraint index
	};

	// Optimize the soft body settings for simulation. This will reorder constraints so they can be executed in parallel.
	void				Optimize(OptimizationResults &outResults);

	// Optimize the soft body settings without results
	void				Optimize()									{ OptimizationResults results; Optimize(results); }

	// Clone this object
	Ref<SoftBodySharedSettings> Clone() const;

	// Saves the state of this object in binary form to inStream. Doesn't store the material list.
	void				SaveBinaryState(StreamOut &inStream) const;

	// Restore the state of this object from inStream. Doesn't restore the material list.
	void				RestoreBinaryState(StreamIn &inStream);

	using SharedSettingsToIDMap = StreamUtils::ObjectToIDMap<SoftBodySharedSettings>;
	using IDToSharedSettingsMap = StreamUtils::IDToObjectMap<SoftBodySharedSettings>;
	using MaterialToIDMap = StreamUtils::ObjectToIDMap<PhysicsMaterial>;
	using IDToMaterialMap = StreamUtils::IDToObjectMap<PhysicsMaterial>;

	// Save this shared settings and its materials. Pass in an empty map ioSettingsMap / ioMaterialMap or reuse the same map while saving multiple settings objects to the same stream in order to avoid writing duplicates.
	void				SaveWithMaterials(StreamOut &inStream, SharedSettingsToIDMap &ioSettingsMap, MaterialToIDMap &ioMaterialMap) const;

	using SettingsResult = Result<Ref<SoftBodySharedSettings>>;

	// Restore a shape and materials. Pass in an empty map in ioSettingsMap / ioMaterialMap or reuse the same map while reading multiple settings objects from the same stream in order to restore duplicates.
	static SettingsResult sRestoreWithMaterials(StreamIn &inStream, IDToSharedSettingsMap &ioSettingsMap, IDToMaterialMap &ioMaterialMap);

	// Create a cube. This can be used to create a simple soft body for testing purposes.
	// It will contain edge constraints, volume constraints and faces.
	// @param inGridSize Number of points along each axis
	// @param inGridSpacing Distance between points
	static Ref<SoftBodySharedSettings> sCreateCube(uint inGridSize, float inGridSpacing);

	// A vertex is a particle, the data in this structure is only used during creation of the soft body and not during simulation
	struct MOSS_EXPORT Vertex
	{
		MOSS_DECLARE_SERIALIZABLE_NON_VIRTUAL(MOSS_EXPORT, Vertex)

		// Constructor
						Vertex() = default;
						Vertex(const Float3 &inPosition, const Float3 &inVelocity = Float3(0, 0, 0), float inInvMass = 1.0f) : mPosition(inPosition), mVelocity(inVelocity), mInvMass(inInvMass) { }

		Float3			mPosition { 0, 0, 0 };						// Initial position of the vertex
		Float3			mVelocity { 0, 0, 0 };						// Initial velocity of the vertex
		float			mInvMass = 1.0f;							// Initial inverse of the mass of the vertex
	};

	// A face defines the surface of the body
	struct MOSS_EXPORT Face
	{
		MOSS_DECLARE_SERIALIZABLE_NON_VIRTUAL(MOSS_EXPORT, Face)

		// Constructor
						Face() = default;
						Face(uint32 inVertex1, uint32 inVertex2, uint32 inVertex3, uint32 inMaterialIndex = 0) : mVertex { inVertex1, inVertex2, inVertex3 }, mMaterialIndex(inMaterialIndex) { }

		// Check if this is a degenerate face (a face which points to the same vertex twice)
		bool			IsDegenerate() const						{ return mVertex[0] == mVertex[1] || mVertex[0] == mVertex[2] || mVertex[1] == mVertex[2]; }

		uint32			mVertex[3];									// Indices of the vertices that form the face
		uint32			mMaterialIndex = 0;							// Index of the material of the face in SoftBodySharedSettings::mMaterials
	};

	// An edge keeps two vertices at a constant distance using a spring: |x1 - x2| = rest length
	struct MOSS_EXPORT Edge
	{
		MOSS_DECLARE_SERIALIZABLE_NON_VIRTUAL(MOSS_EXPORT, Edge)

		// Constructor
						Edge() = default;
						Edge(uint32 inVertex1, uint32 inVertex2, float inCompliance = 0.0f) : mVertex { inVertex1, inVertex2 }, mCompliance(inCompliance) { }

		// Return the lowest vertex index of this constraint
		uint32			GetMinVertexIndex() const					{ return min(mVertex[0], mVertex[1]); }

		uint32			mVertex[2];									// Indices of the vertices that form the edge
		float			mRestLength = 1.0f;							// Rest length of the spring
		float			mCompliance = 0.0f;							// Inverse of the stiffness of the spring
	};

	/**
	 * A dihedral bend constraint keeps the angle between two triangles constant along their shared edge.
	 *
	 *        x2
	 *       /  \
	 *      / t0 \
	 *     x0----x1
	 *      \ t1 /
	 *       \  /
	 *        x3
	 *
	 * x0..x3 are the vertices, t0 and t1 are the triangles that share the edge x0..x1
	 *
	 * Based on:
	 * - "Position Based Dynamics" - Matthias Muller et al.
	 * - "Strain Based Dynamics" - Matthias Muller et al.
	 * - "Simulation of Clothing with Folds and Wrinkles" - R. Bridson et al.
	 */
	struct MOSS_EXPORT DihedralBend
	{
		MOSS_DECLARE_SERIALIZABLE_NON_VIRTUAL(MOSS_EXPORT, DihedralBend)

		// Constructor
						DihedralBend() = default;
						DihedralBend(uint32 inVertex1, uint32 inVertex2, uint32 inVertex3, uint32 inVertex4, float inCompliance = 0.0f) : mVertex { inVertex1, inVertex2, inVertex3, inVertex4 }, mCompliance(inCompliance) { }

		// Return the lowest vertex index of this constraint
		uint32			GetMinVertexIndex() const					{ return min(min(mVertex[0], mVertex[1]), min(mVertex[2], mVertex[3])); }

		uint32			mVertex[4];									// Indices of the vertices of the 2 triangles that share an edge (the first 2 vertices are the shared edge)
		float			mCompliance = 0.0f;							// Inverse of the stiffness of the constraint
		float			mInitialAngle = 0.0f;						// Initial angle between the normals of the triangles (pi - dihedral angle).
	};

	// Volume constraint, keeps the volume of a tetrahedron constant
	struct MOSS_EXPORT Volume
	{
		MOSS_DECLARE_SERIALIZABLE_NON_VIRTUAL(MOSS_EXPORT, Volume)

		// Constructor
						Volume() = default;
						Volume(uint32 inVertex1, uint32 inVertex2, uint32 inVertex3, uint32 inVertex4, float inCompliance = 0.0f) : mVertex { inVertex1, inVertex2, inVertex3, inVertex4 }, mCompliance(inCompliance) { }

		// Return the lowest vertex index of this constraint
		uint32			GetMinVertexIndex() const					{ return min(min(mVertex[0], mVertex[1]), min(mVertex[2], mVertex[3])); }

		uint32			mVertex[4];									// Indices of the vertices that form the tetrahedron
		float			mSixRestVolume = 1.0f;						// 6 times the rest volume of the tetrahedron (calculated by CalculateVolumeConstraintVolumes())
		float			mCompliance = 0.0f;							// Inverse of the stiffness of the constraint
	};

	// An inverse bind matrix take a skinned vertex from its bind pose into joint local space
	class MOSS_EXPORT InvBind
	{
		MOSS_DECLARE_SERIALIZABLE_NON_VIRTUAL(MOSS_EXPORT, InvBind)

	public:
		// Constructor
						InvBind() = default;
						InvBind(uint32 inJointIndex, Mat44Arg inInvBind) : mJointIndex(inJointIndex), mInvBind(inInvBind) { }

		uint32			mJointIndex = 0;							// Joint index to which this is attached
		Mat44			mInvBind = Mat44::sIdentity();				// The inverse bind matrix, this takes a vertex in its bind pose (Vertex::mPosition) to joint local space
	};

	// A joint and its skin weight
	class MOSS_EXPORT SkinWeight
	{
		MOSS_DECLARE_SERIALIZABLE_NON_VIRTUAL(MOSS_EXPORT, SkinWeight)

	public:
		// Constructor
						SkinWeight() = default;
						SkinWeight(uint32 inInvBindIndex, float inWeight) : mInvBindIndex(inInvBindIndex), mWeight(inWeight) { }

		uint32			mInvBindIndex = 0;							// Index in mInvBindMatrices
		float			mWeight = 0.0f;								// Weight with which it is skinned
	};

	// A constraint that skins a vertex to joints and limits the distance that the simulated vertex can travel from this vertex
	class MOSS_EXPORT Skinned
	{
		MOSS_DECLARE_SERIALIZABLE_NON_VIRTUAL(MOSS_EXPORT, Skinned)

	public:
		// Constructor
						Skinned() = default;
						Skinned(uint32 inVertex, float inMaxDistance, float inBackStopDistance, float inBackStopRadius) : mVertex(inVertex), mMaxDistance(inMaxDistance), mBackStopDistance(inBackStopDistance), mBackStopRadius(inBackStopRadius) { }

		// Normalize the weights so that they add up to 1
		void			NormalizeWeights()
		{
			// Get the total weight
			float total = 0.0f;
			for (const SkinWeight &w : mWeights)
				total += w.mWeight;

			// Normalize
			if (total > 0.0f)
				for (SkinWeight &w : mWeights)
					w.mWeight /= total;
		}

		// Maximum number of skin weights
		static constexpr uint cMaxSkinWeights = 4;

		uint32			mVertex = 0;								// Index in mVertices which indicates which vertex is being skinned
		SkinWeight		mWeights[cMaxSkinWeights];					// Skin weights, the bind pose of the vertex is assumed to be stored in Vertex::mPosition. The first weight that is zero indicates the end of the list. Weights should add up to 1.
		float			mMaxDistance = FLT_MAX;						// Maximum distance that this vertex can reach from the skinned vertex, disabled when FLT_MAX. 0 when you want to hard skin the vertex to the skinned vertex.
		float			mBackStopDistance = FLT_MAX;				// Disabled if mBackStopDistance >= mMaxDistance. The faces surrounding mVertex determine an average normal. mBackStopDistance behind the vertex in the opposite direction of this normal, the back stop sphere starts. The simulated vertex will be pushed out of this sphere and it can be used to approximate the volume of the skinned mesh behind the skinned vertex.
		float			mBackStopRadius = 40.0f;					// Radius of the backstop sphere. By default this is a fairly large radius so the sphere approximates a plane.
		uint32			mNormalInfo = 0;							// Information needed to calculate the normal of this vertex, lowest 24 bit is start index in mSkinnedConstraintNormals, highest 8 bit is number of faces (generated by CalculateSkinnedConstraintNormals())
	};

	// A long range attachment constraint, this is a constraint that sets a max distance between a kinematic vertex and a dynamic vertex
	// See: "Long Range Attachments - A Method to Simulate Inextensible Clothing in Computer Games", Tae-Yong Kim, Nuttapong Chentanez and Matthias Mueller-Fischer
	class MOSS_EXPORT LRA
	{
		MOSS_DECLARE_SERIALIZABLE_NON_VIRTUAL(MOSS_EXPORT, LRA)

	public:
		// Constructor
						LRA() = default;
						LRA(uint32 inVertex1, uint32 inVertex2, float inMaxDistance) : mVertex { inVertex1, inVertex2 }, mMaxDistance(inMaxDistance) { }

		// Return the lowest vertex index of this constraint
		uint32			GetMinVertexIndex() const					{ return min(mVertex[0], mVertex[1]); }

		uint32			mVertex[2];									// The vertices that are connected. The first vertex should be kinematic, the 2nd dynamic.
		float			mMaxDistance = 0.0f;						// The maximum distance between the vertices
	};

	// Add a face to this soft body
	void				AddFace(const Face &inFace)					{ MOSS_ASSERT(!inFace.IsDegenerate()); mFaces.push_back(inFace); }

	TArray<Vertex>			mVertices;									// The list of vertices or particles of the body
	TArray<Face>			mFaces;										// The list of faces of the body
	TArray<Edge>			mEdgeConstraints;							// The list of edges or springs of the body
	TArray<DihedralBend>	mDihedralBendConstraints;					// The list of dihedral bend constraints of the body
	TArray<Volume>			mVolumeConstraints;							// The list of volume constraints of the body that keep the volume of tetrahedra in the soft body constant
	TArray<Skinned>			mSkinnedConstraints;						// The list of vertices that are constrained to a skinned vertex
	TArray<InvBind>			mInvBindMatrices;							// The list of inverse bind matrices for skinning vertices
	TArray<LRA>				mLRAConstraints;							// The list of long range attachment constraints
	PhysicsMaterialList 	mMaterials { PhysicsMaterial::sDefault };	// The materials of the faces of the body, referenced by Face::mMaterialIndex
	float					mVertexRadius = 0.0f;						// How big the particles are, can be used to push the vertices a little bit away from the surface of other bodies to prevent z-fighting

private:
	friend class SoftBodyMotionProperties;

	// Calculate the closest kinematic vertex array
	void				CalculateClosestKinematic();

	// Tracks the closest kinematic vertex
	struct ClosestKinematic
	{
		uint32			mVertex = 0xffffffff;						// Vertex index of closest kinematic vertex
		float			mDistance = FLT_MAX;						// Distance to the closest kinematic vertex
	};

	// Tracks the end indices of the various constraint groups
	struct UpdateGroup
	{
		uint			mEdgeEndIndex;								// The end index of the edge constraints in this group
		uint			mLRAEndIndex;								// The end index of the LRA constraints in this group
		uint			mDihedralBendEndIndex;						// The end index of the dihedral bend constraints in this group
		uint			mVolumeEndIndex;							// The end index of the volume constraints in this group
		uint			mSkinnedEndIndex;							// The end index of the skinned constraints in this group
	};

	TArray<ClosestKinematic> mClosestKinematic;						// The closest kinematic vertex to each vertex in mVertices
	TArray<UpdateGroup>	mUpdateGroups;								// The end indices for each group of constraints that can be updated in parallel
	TArray<uint32>		mSkinnedConstraintNormals;					// A list of indices in the mFaces array used by mSkinnedConstraints, calculated by CalculateSkinnedConstraintNormals()
};

class MOSS_API SoftBodyCreationSettings {
public:
	// Constructor
						SoftBodyCreationSettings() = default;
						SoftBodyCreationSettings(const SoftBodySharedSettings *inSettings, RVec3Arg inPosition, QuatArg inRotation, ObjectLayer inObjectLayer) : mSettings(inSettings), mPosition(inPosition), mRotation(inRotation), mObjectLayer(inObjectLayer) { }

	// Saves the state of this object in binary form to inStream. Doesn't store the shared settings nor the group filter.
	void				SaveBinaryState(StreamOut &inStream) const;

	// Restore the state of this object from inStream. Doesn't restore the shared settings nor the group filter.
	void				RestoreBinaryState(StreamIn &inStream);

	using GroupFilterToIDMap = StreamUtils::ObjectToIDMap<GroupFilter>;
	using IDToGroupFilterMap = StreamUtils::IDToObjectMap<GroupFilter>;
	using SharedSettingsToIDMap = SoftBodySharedSettings::SharedSettingsToIDMap;
	using IDToSharedSettingsMap = SoftBodySharedSettings::IDToSharedSettingsMap;
	using MaterialToIDMap = StreamUtils::ObjectToIDMap<PhysicsMaterial>;
	using IDToMaterialMap = StreamUtils::IDToObjectMap<PhysicsMaterial>;

	// Save this body creation settings, its shared settings and group filter. Pass in an empty map in ioSharedSettingsMap / ioMaterialMap / ioGroupFilterMap or reuse the same map while saving multiple shapes to the same stream in order to avoid writing duplicates.
	// Pass nullptr to ioSharedSettingsMap and ioMaterial map to skip saving shared settings and materials
	// Pass nullptr to ioGroupFilterMap to skip saving group filters
	void				SaveWithChildren(StreamOut &inStream, SharedSettingsToIDMap *ioSharedSettingsMap, MaterialToIDMap *ioMaterialMap, GroupFilterToIDMap *ioGroupFilterMap) const;

	using SBCSResult = Result<SoftBodyCreationSettings>;

	// Restore a shape, all its children and materials. Pass in an empty map in ioSharedSettingsMap / ioMaterialMap / ioGroupFilterMap or reuse the same map while reading multiple shapes from the same stream in order to restore duplicates.
	static SBCSResult	sRestoreWithChildren(StreamIn &inStream, IDToSharedSettingsMap &ioSharedSettingsMap, IDToMaterialMap &ioMaterialMap, IDToGroupFilterMap &ioGroupFilterMap);

	RefConst<SoftBodySharedSettings> mSettings;				// Defines the configuration of this soft body

	RVec3				mPosition { RVec3::sZero() };		// Initial position of the soft body
	Quat				mRotation { Quat::sIdentity() };	// Initial rotation of the soft body

	// User data value (can be used by application)
	uint64				mUserData = 0;

	//@name Collision settings
	ObjectLayer			mObjectLayer = 0;					// The collision layer this body belongs to (determines if two objects can collide)
	CollisionGroup		mCollisionGroup;					// The collision group this body belongs to (determines if two objects can collide)

	uint32				mNumIterations = 5;					// Number of solver iterations
	float				mLinearDamping = 0.1f;				// Linear damping: dv/dt = -mLinearDamping * v
	float				mMaxLinearVelocity = 500.0f;		// Maximum linear velocity that a vertex can reach (m/s)
	float				mRestitution = 0.0f;				// Restitution when colliding
	float				mFriction = 0.2f;					// Friction coefficient when colliding
	float				mPressure = 0.0f;					// n * R * T, amount of substance * ideal gas constant * absolute temperature, see https://en.wikipedia.org/wiki/Pressure
	float				mGravityFactor = 1.0f;				// Value to multiply gravity with for this body
	bool				mUpdatePosition = true;				// Update the position of the body while simulating (set to false for something that is attached to the static world)
	bool				mMakeRotationIdentity = true;		// Bake specified mRotation in the vertices and set the body rotation to identity (simulation is slightly more accurate if the rotation of a soft body is kept to identity)
	bool				mAllowSleeping = true;				// If this body can go to sleep or not
};




// Settings for constructing a rigid body
class MOSS_API BodyCreationSettings
{
	MOSS_DECLARE_SERIALIZABLE_NON_VIRTUAL(MOSS_API, BodyCreationSettings)

public:
	// Constructor
							BodyCreationSettings() = default;
							BodyCreationSettings(const ShapeSettings *inShape, RVec3Arg inPosition, QuatArg inRotation, EMotionType inMotionType, ObjectLayer inObjectLayer) : mPosition(inPosition), mRotation(inRotation), mObjectLayer(inObjectLayer), mMotionType(inMotionType), mShape(inShape) { }
							BodyCreationSettings(const Shape *inShape, RVec3Arg inPosition, QuatArg inRotation, EMotionType inMotionType, ObjectLayer inObjectLayer) : mPosition(inPosition), mRotation(inRotation), mObjectLayer(inObjectLayer), mMotionType(inMotionType), mShapePtr(inShape) { }

	// Access to the shape settings object. This contains serializable (non-runtime optimized) information about the Shape.
	const ShapeSettings *	GetShapeSettings() const										{ return mShape; }
	void					SetShapeSettings(const ShapeSettings *inShape)					{ mShape = inShape; mShapePtr = nullptr; }

	// Convert ShapeSettings object into a Shape object. This will free the ShapeSettings object and make the object ready for runtime. Serialization is no longer possible after this.
	Shape::ShapeResult		ConvertShapeSettings();

	// Access to the run-time shape object. Will convert from ShapeSettings object if needed.
	const Shape *			GetShape() const;
	void					SetShape(const Shape *inShape)									{ mShapePtr = inShape; mShape = nullptr; }

	// Check if the mass properties of this body will be calculated (only relevant for kinematic or dynamic objects that need a MotionProperties object)
	bool					HasMassProperties() const										{ return mAllowDynamicOrKinematic || mMotionType != EMotionType::Static; }

	// Calculate (or return when overridden) the mass and inertia for this body
	MassProperties			GetMassProperties() const;

	// Saves the state of this object in binary form to inStream. Doesn't store the shape nor the group filter.
	void					SaveBinaryState(StreamOut &inStream) const;

	// Restore the state of this object from inStream. Doesn't restore the shape nor the group filter.
	void					RestoreBinaryState(StreamIn &inStream);

	using GroupFilterToIDMap = StreamUtils::ObjectToIDMap<GroupFilter>;
	using IDToGroupFilterMap = StreamUtils::IDToObjectMap<GroupFilter>;
	using ShapeToIDMap = Shape::ShapeToIDMap;
	using IDToShapeMap = Shape::IDToShapeMap;
	using MaterialToIDMap = StreamUtils::ObjectToIDMap<PhysicsMaterial>;
	using IDToMaterialMap = StreamUtils::IDToObjectMap<PhysicsMaterial>;

	// Save body creation settings, its shape, materials and group filter. Pass in an empty map in ioShapeMap / ioMaterialMap / ioGroupFilterMap or reuse the same map while saving multiple shapes to the same stream in order to avoid writing duplicates.
	// Pass nullptr to ioShapeMap and ioMaterial map to skip saving shapes
	// Pass nullptr to ioGroupFilterMap to skip saving group filters
	void					SaveWithChildren(StreamOut &inStream, ShapeToIDMap *ioShapeMap, MaterialToIDMap *ioMaterialMap, GroupFilterToIDMap *ioGroupFilterMap) const;

	using BCSResult = Result<BodyCreationSettings>;

	// Restore body creation settings, its shape, materials and group filter. Pass in an empty map in ioShapeMap / ioMaterialMap / ioGroupFilterMap or reuse the same map while reading multiple shapes from the same stream in order to restore duplicates.
	static BCSResult		sRestoreWithChildren(StreamIn &inStream, IDToShapeMap &ioShapeMap, IDToMaterialMap &ioMaterialMap, IDToGroupFilterMap &ioGroupFilterMap);

	RVec3					mPosition = RVec3::sZero();										// Position of the body (not of the center of mass)
	Quat					mRotation = Quat::sIdentity();									// Rotation of the body
	Vec3					mLinearVelocity = Vec3::sZero();								// World space linear velocity of the center of mass (m/s)
	Vec3					mAngularVelocity = Vec3::sZero();								// World space angular velocity (rad/s)

	// User data value (can be used by application)
	uint64					mUserData = 0;

	//@name Collision settings
	ObjectLayer				mObjectLayer = 0;												// The collision layer this body belongs to (determines if two objects can collide)
	CollisionGroup			mCollisionGroup;												// The collision group this body belongs to (determines if two objects can collide)

	//@name Simulation properties
	EMotionType				mMotionType = EMotionType::Dynamic;								// Motion type, determines if the object is static, dynamic or kinematic
	EAllowedDOFs			mAllowedDOFs = EAllowedDOFs::All;								// Which degrees of freedom this body has (can be used to limit simulation to 2D)
	bool					mAllowDynamicOrKinematic = false;								// When this body is created as static, this setting tells the system to create a MotionProperties object so that the object can be switched to kinematic or dynamic
	bool					mIsSensor = false;												// If this body is a sensor. A sensor will receive collision callbacks, but will not cause any collision responses and can be used as a trigger volume. See description at Body::SetIsSensor.
	bool					mCollideKinematicVsNonDynamic = false;							// If kinematic objects can generate contact points against other kinematic or static objects. See description at Body::SetCollideKinematicVsNonDynamic.
	bool					mUseManifoldReduction = true;									// If this body should use manifold reduction (see description at Body::SetUseManifoldReduction)
	bool					mApplyGyroscopicForce = false;									// Set to indicate that the gyroscopic force should be applied to this body (aka Dzhanibekov effect, see https://en.wikipedia.org/wiki/Tennis_racket_theorem)
	EMotionQuality			mMotionQuality = EMotionQuality::Discrete;						// Motion quality, or how well it detects collisions when it has a high velocity
	bool					mEnhancedInternalEdgeRemoval = false;							// Set to indicate that extra effort should be made to try to remove ghost contacts (collisions with internal edges of a mesh). This is more expensive but makes bodies move smoother over a mesh with convex edges.
	bool					mAllowSleeping = true;											// If this body can go to sleep or not
	float					mFriction = 0.2f;												// Friction of the body (dimensionless number, usually between 0 and 1, 0 = no friction, 1 = friction force equals force that presses the two bodies together). Note that bodies can have negative friction but the combined friction (see PhysicsSystem::SetCombineFriction) should never go below zero.
	float					mRestitution = 0.0f;											// Restitution of body (dimensionless number, usually between 0 and 1, 0 = completely inelastic collision response, 1 = completely elastic collision response). Note that bodies can have negative restitution but the combined restitution (see PhysicsSystem::SetCombineRestitution) should never go below zero.
	float					mLinearDamping = 0.05f;											// Linear damping: dv/dt = -c * v. c must be between 0 and 1 but is usually close to 0.
	float					mAngularDamping = 0.05f;										// Angular damping: dw/dt = -c * w. c must be between 0 and 1 but is usually close to 0.
	float					mMaxLinearVelocity = 500.0f;									// Maximum linear velocity that this body can reach (m/s)
	float					mMaxAngularVelocity = 0.25f * MOSS_PI * 60.0f;					// Maximum angular velocity that this body can reach (rad/s)
	float					mGravityFactor = 1.0f;											// Value to multiply gravity with for this body
	uint					mNumVelocityStepsOverride = 0;									// Used only when this body is dynamic and colliding. Override for the number of solver velocity iterations to run, 0 means use the default in PhysicsSettings::mNumVelocitySteps. The number of iterations to use is the max of all contacts and constraints in the island.
	uint					mNumPositionStepsOverride = 0;									// Used only when this body is dynamic and colliding. Override for the number of solver position iterations to run, 0 means use the default in PhysicsSettings::mNumPositionSteps. The number of iterations to use is the max of all contacts and constraints in the island.

	//@name Mass properties of the body (by default calculated by the shape)
	EOverrideMassProperties	mOverrideMassProperties = EOverrideMassProperties::CalculateMassAndInertia; // Determines how mMassPropertiesOverride will be used
	float					mInertiaMultiplier = 1.0f;										// When calculating the inertia (not when it is provided) the calculated inertia will be multiplied by this value
	MassProperties			mMassPropertiesOverride;										// Contains replacement mass settings which override the automatically calculated values

private:
	// Collision volume for the body
	RefConst<ShapeSettings>	mShape;															// Shape settings, can be serialized. Mutually exclusive with mShapePtr
	RefConst<Shape>			mShapePtr;														// Actual shape, cannot be serialized. Mutually exclusive with mShape
};
